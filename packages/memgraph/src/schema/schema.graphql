enum Codex {
  JSON
}

type State @node {
  id: ID! @id
  hash: String!
  codex: Codex!
  timestamp_created: BigInt! @populatedBy(callback: "now", operations: [CREATE])
  timestamp_updated: BigInt @populatedBy(callback: "now", operations: [UPDATE])
  api_version: String!
    @populatedBy(callback: "apiVersion", operations: [CREATE, UPDATE])
  states_next: [State!]!
    @relationship(type: "NEXT", properties: "Transition", direction: OUT)
  states_previous: [State!]!
    @relationship(type: "NEXT", properties: "Transition", direction: IN)
}

type Transition @relationshipProperties {
  id: ID! @id
  cost: Float!
  rule_name: String!
  metadata: String
  timestamp_created: BigInt! @populatedBy(callback: "now", operations: [CREATE])
  timestamp_updated: BigInt @populatedBy(callback: "now", operations: [UPDATE])
  api_version: String!
    @populatedBy(callback: "apiVersion", operations: [CREATE, UPDATE])
}

input StateUpsertInput {
  hash: String!
  codex: Codex!
}

type UpsertStatesMutationResponse {
  states: [State!]!
  info: UpsertInfo!
}

type UpsertInfo {
  nodesCreated: Int!
  nodesUpdated: Int!
}

input CreateTransitionInput {
  rootStateHash: String!
  nextStateHashes: [String!]!
  cost: Float!
  ruleName: String!
  metadata: String
}

type CreateTransitionMutationResponse {
  transitions: [Transition!]!
}

type Mutation {
  createTransition(
    input: CreateTransitionInput!
  ): CreateTransitionMutationResponse!
    @cypher(
      statement: """
      MATCH (root:State {hash: $input.rootStateHash})
      WITH root, $input AS input,
          $apiVersion AS apiVersion,
          timestamp() AS now

      // Expand target hashes; if empty, keep one null so we still return a row
      UNWIND (CASE
                WHEN input.nextStateHashes IS NULL OR size(input.nextStateHashes) = 0
                  THEN [NULL]
                ELSE input.nextStateHashes
              END) AS h

      OPTIONAL MATCH (next:State {hash: h})
      WITH root, input, apiVersion, now, next, h
      WHERE h IS NOT NULL AND next IS NOT NULL

      CALL uuid_generator.get() YIELD uuid
      CREATE (root)-[rel:NEXT {
        id: uuid,
        timestamp_created: now,
        cost: input.cost,
        rule_name: input.ruleName,
        api_version: apiVersion
      }]->(next)

      SET
        root.api_version = coalesce(apiVersion, root.api_version),
        root.timestamp_updated = now,
        next.api_version = coalesce(apiVersion, next.api_version),
        next.timestamp_updated = now

      // set metadata only if provided
      FOREACH (_ IN CASE WHEN input.metadata IS NOT NULL THEN [1] ELSE [] END |
        SET rel.metadata = input.metadata
      )

      WITH root, collect(rel {
        id: rel.id,
        cost: rel.cost,
        rule_name: rel.rule_name,
        metadata: rel.metadata,
        timestamp_created: rel.timestamp_created,
        timestamp_updated: rel.timestamp_updated,
        api_version: rel.api_version
      }) AS transitions

      RETURN { transitions: transitions } AS result
      """
      columnName: "result"
    )

  upsertStates(input: [StateUpsertInput!]!): UpsertStatesMutationResponse!
    @cypher(
      statement: """
      UNWIND $input AS input
      WITH input, $apiVersion AS apiVersion, timestamp() AS now
      CALL uuid_generator.get() YIELD uuid
      MERGE (s:State {hash: input.hash})
      ON CREATE SET
        s.codex = input.codex,
        s.timestamp_created = now,
        s.id = uuid
      SET
        s.timestamp_updated = now,
        s.api_version = coalesce(apiVersion, s.api_version)

      WITH s, (s.timestamp_created = now) AS wasCreated
      WITH
        collect(s{
          .hash, .id, .codex,
          .timestamp_created, .timestamp_updated, .api_version
        }) AS states,
        sum(CASE WHEN wasCreated THEN 1 ELSE 0 END) AS nodesCreated,
        sum(CASE WHEN wasCreated THEN 0 ELSE 1 END) AS nodesUpdated
      RETURN {
        states: states,
        info: { nodesCreated: nodesCreated, nodesUpdated: nodesUpdated }
      } AS result
      """
      columnName: "result"
    )
}
