enum Codex {
  JSON
}

type State @node {
  id: ID! @id
  hash: String!
  system_hash: String!
  codex: Codex!
  timestamp_created: BigInt! @populatedBy(callback: "now", operations: [CREATE])
  timestamp_updated: BigInt @populatedBy(callback: "now", operations: [UPDATE])
  api_version: String!
    @populatedBy(callback: "apiVersion", operations: [CREATE, UPDATE])
  states_next: [State!]!
    @relationship(type: "NEXT", properties: "Transition", direction: OUT)
  states_previous: [State!]!
    @relationship(type: "NEXT", properties: "Transition", direction: IN)
}

type Transition @relationshipProperties {
  id: ID! @id
  cost: Float!
  rule_name: String!
  metadata: String
  hash: String!
  codex: Codex!
  timestamp_created: BigInt! @populatedBy(callback: "now", operations: [CREATE])
  timestamp_updated: BigInt @populatedBy(callback: "now", operations: [UPDATE])
  api_version: String!
    @populatedBy(callback: "apiVersion", operations: [CREATE, UPDATE])
}

input StateUpsertInput {
  hash: String!
  codex: Codex!
  system_hash: String!
}

type UpsertStatesMutationResponse {
  states: [State!]!
  info: UpsertInfo!
}

type UpsertInfo {
  nodesCreated: Int!
  nodesUpdated: Int!
}

input TransitionInfo {
  hash: String!
  codex: Codex!
  cost: Float!
  ruleName: String!
  metadata: String
}

input CreateTransitionInput {
  rootState: StateUpsertInput!
  nextStates: [StateUpsertInput!]!
  transition: TransitionInfo!
}

type CreateTransitionMutationResponse {
  transitions: [Transition!]!
}

type Mutation {
  createTransition(
    input: CreateTransitionInput!
  ): CreateTransitionMutationResponse!
    @cypher(
      statement: """
      MATCH (root:State {hash: $input.rootState.hash, codex: $input.rootState.codex, system_hash: $input.rootState.system_hash})
      WITH root, $input AS input, $apiVersion AS apiVersion, timestamp() AS now

      UNWIND (
        CASE
          WHEN input.nextStates IS NULL OR size(input.nextStates) = 0
            THEN [NULL]
          ELSE input.nextStates
        END
      ) AS nextState

      OPTIONAL MATCH (next:State {hash: nextState.hash, codex: nextState.codex, system_hash: nextState.system_hash})
      WITH root, input, apiVersion, now, next, nextState
      WHERE nextState IS NOT NULL AND next IS NOT NULL

      CALL uuid_generator.get() YIELD uuid

      // Deduplicate by {hash, codex} for this (root,next) pair
      MERGE (root)-[rel:NEXT { hash: input.transition.hash, codex: input.transition.codex }]->(next)
      ON CREATE SET
        rel.id = uuid,
        rel.timestamp_created = now

      // Common updates (both create & match)
      SET
        rel.cost = input.transition.cost,
        rel.rule_name = input.transition.ruleName,
        rel.timestamp_updated = now,
        rel.api_version = coalesce(apiVersion, rel.api_version),
        root.api_version = coalesce(apiVersion, root.api_version),
        root.timestamp_updated = now,
        next.api_version = coalesce(apiVersion, next.api_version),
        next.timestamp_updated = now

      // Only set metadata when provided
      FOREACH (_ IN CASE WHEN input.transition.metadata IS NOT NULL THEN [1] ELSE [] END |
        SET rel.metadata = input.transition.metadata
      )

      WITH root, collect(rel {
        .id,
        .cost,
        .rule_name,
        .metadata,
        .timestamp_created,
        .timestamp_updated,
        .api_version
      }) AS transitions

      RETURN { transitions: transitions } AS result
      """
      columnName: "result"
    )

  upsertStates(input: [StateUpsertInput!]!): UpsertStatesMutationResponse!
    @cypher(
      statement: """
      UNWIND $input AS input
      WITH input, $apiVersion AS apiVersion, timestamp() AS now
      CALL uuid_generator.get() YIELD uuid
      MERGE (s:State {hash: input.hash, codex: input.codex, system_hash: input.system_hash})
      ON CREATE SET
        s.codex = input.codex,
        s.timestamp_created = now,
        s.id = uuid
      SET
        s.timestamp_updated = now,
        s.api_version = coalesce(apiVersion, s.api_version)

      WITH s, (s.timestamp_created = now) AS wasCreated
      WITH
        collect(s{
          .hash, .id, .codex, .system_hash,
          .timestamp_created, .timestamp_updated, .api_version
        }) AS states,
        sum(CASE WHEN wasCreated THEN 1 ELSE 0 END) AS nodesCreated,
        sum(CASE WHEN wasCreated THEN 0 ELSE 1 END) AS nodesUpdated
      RETURN {
        states: states,
        info: { nodesCreated: nodesCreated, nodesUpdated: nodesUpdated }
      } AS result
      """
      columnName: "result"
    )
}
